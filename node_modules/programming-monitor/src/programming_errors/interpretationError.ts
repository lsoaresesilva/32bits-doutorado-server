import { ErrorCategory } from "../enum/errorCategory";

/* Every error found in the Python traceback is represented as an instance of InterpretationError subclass. */
export abstract class InterpretationError {
  protected constructor(public traceback: string) {
    this.line = InterpretationError.getLine(traceback);
    this.category = InterpretationError.getCategory(traceback);
  }

  line: number;
  category: ErrorCategory;

  static getLine(traceback: string) {
    if (traceback != null) {
      const pattern = /line ([0-9]+)/;
      const match = traceback.match(pattern);

      if (match != null) {
        return parseInt(match[1]);
      }
    }

    throw new Error("Could not identify error line.");
  }

  static isErro(traceback: string) {
    if (traceback != null) {
      const padrao = /([a-zA-Z]+)Error:/;
      const consulta = traceback.match(padrao);
      if (consulta != null) {
        return true;
      }
    }
    return false;
  }

  /**
   * Every error belongs to a category
   * @param traceback
   */
  static getCategory(traceback: string) {
    if (traceback != null) {
      const padrao = /([a-zA-Z]+Erro[a-z]+):/;
      const consulta = traceback.match(padrao);

      if (consulta != null) {
        if (consulta[1] == "NameError") {
          return ErrorCategory.nameError;
        } else if (consulta[1] == "SyntaxError") {
          return ErrorCategory.syntaxError;
        } else if (consulta[1] == "TypeError") {
          return ErrorCategory.typeError;
        } else if (consulta[1] == "IndentationError") {
          return ErrorCategory.indentationError;
        }
      }
    }

    throw new Error("Could not identify error category.");
  }
}
